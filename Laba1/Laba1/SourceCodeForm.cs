using System;
using System.Windows.Forms;

namespace Laba1
{
    public partial class SourceCodeForm: Form
    {
        public SourceCodeForm()
        {
            InitializeComponent();
        }

        private void CompilerButton_Click(object sender, EventArgs e)
        {
            richTextBox.Clear();
            richTextBox.Text = "using System;\r\nusing System.Diagnostics;\r\nusing System.IO;\r\nusing System.Windows.Forms;\r\n\r\nnamespace Laba1\r\n{\r\n    public partial class Compiler : Form\r\n    {\r\n        private string currentFile = string.Empty;\r\n\r\n        public Compiler()\r\n        {\r\n            InitializeComponent();\r\n        }\r\n\r\n        /*ФАЙЛ*/\r\n\r\n\r\n        private void создатьToolStripMenuItem_Click(object sender, EventArgs e)\r\n        {\r\n            // Если в редакторе есть текст (возможно, изменения)\r\n            if (!string.IsNullOrWhiteSpace(richTextBox1.Text))\r\n            {\r\n                DialogResult result = MessageBox.Show(\r\n                    \"Сохранить изменения в текущем документе?\",\r\n                    \"Сохранение изменений\",\r\n                    MessageBoxButtons.YesNoCancel,\r\n                    MessageBoxIcon.Question);\r\n\r\n                if (result == DialogResult.Yes)\r\n                {\r\n                    // Вызываем функцию \"Сохранить как\" для сохранения изменений\r\n                    сохранитьКакToolStripMenuItem_Click(sender, e);\r\n                }\r\n                else if (result == DialogResult.Cancel)\r\n                {\r\n                    // Если пользователь отменил, прерываем создание нового файла\r\n                    return;\r\n                }\r\n            }\r\n\r\n            // Открываем диалоговое окно для создания нового файла\r\n            SaveFileDialog sfd = new SaveFileDialog\r\n            {\r\n                Title = \"Создать новый документ\",\r\n                Filter = \"Text Files (*.txt)|*.txt|All Files (*.*)|*.*\"\r\n            };\r\n\r\n            if (sfd.ShowDialog() == DialogResult.OK)\r\n            {\r\n                currentFile = sfd.FileName;\r\n                try\r\n                {\r\n                    // Физически создаём пустой файл\r\n                    File.WriteAllText(currentFile, \"\");\r\n                    // Очищаем редактор для нового документа\r\n                    richTextBox1.Clear();\r\n                }\r\n                catch (Exception ex)\r\n                {\r\n                    MessageBox.Show(\"Ошибка при создании файла: \" + ex.Message, \"Ошибка\", MessageBoxButtons.OK, MessageBoxIcon.Error);\r\n                }\r\n            }\r\n        }\r\n\r\n        private void открытьToolStripMenuItem_Click(object sender, EventArgs e)\r\n        {\r\n            OpenFileDialog ofd = new OpenFileDialog();\r\n            ofd.Filter = \"Text Files (*.txt)|*.txt|All Files (*.*)|*.*\";\r\n\r\n            if (ofd.ShowDialog() == DialogResult.OK)\r\n            {\r\n                currentFile = ofd.FileName;\r\n                richTextBox1.Text = File.ReadAllText(currentFile);\r\n            }\r\n        }\r\n\r\n        private void сохранитьToolStripMenuItem_Click(object sender, EventArgs e)\r\n        {\r\n            if (string.IsNullOrEmpty(currentFile))\r\n            {\r\n                // Если файл ещё не был сохранён - вызываем \"Сохранить как\"\r\n                сохранитьКакToolStripMenuItem_Click(sender, e);\r\n            }\r\n            else\r\n            {\r\n                // Сохраняем в текущий файл\r\n                File.WriteAllText(currentFile, richTextBox1.Text);\r\n            }\r\n        }\r\n\r\n        private void сохранитьКакToolStripMenuItem_Click(object sender, EventArgs e)\r\n        {\r\n            SaveFileDialog sfd = new SaveFileDialog();\r\n            sfd.Filter = \"Text Files (*.txt)|*.txt|All Files (*.*)|*.*\";\r\n\r\n            if (sfd.ShowDialog() == DialogResult.OK)\r\n            {\r\n                currentFile = sfd.FileName;\r\n                File.WriteAllText(currentFile, richTextBox1.Text);\r\n            }\r\n        }\r\n\r\n        private void выходToolStripMenuItem_Click(object sender, EventArgs e)\r\n        {\r\n            Application.Exit();\r\n        }\r\n\r\n\r\n        /*ПРАВКА*/\r\n\r\n\r\n        private void отменитьToolStripMenuItem_Click(object sender, EventArgs e)\r\n        {\r\n            if (richTextBox1.CanUndo)\r\n            {\r\n                richTextBox1.Undo();\r\n            }\r\n        }\r\n\r\n        private void повторитьToolStripMenuItem_Click(object sender, EventArgs e)\r\n        {\r\n            if (richTextBox1.CanRedo)\r\n            {\r\n                richTextBox1.Redo();\r\n            }\r\n        }\r\n\r\n        private void копироватьToolStripMenuItem_Click(object sender, EventArgs e)\r\n        {\r\n            if (richTextBox1.SelectionLength > 0)\r\n            {\r\n                richTextBox1.Copy();\r\n            }\r\n        }\r\n\r\n        private void вырезатьToolStripMenuItem_Click(object sender, EventArgs e)\r\n        {\r\n            if (richTextBox1.SelectionLength > 0)\r\n            {\r\n                richTextBox1.Cut();\r\n            }\r\n        }\r\n\r\n        private void вставитьToolStripMenuItem_Click(object sender, EventArgs e)\r\n        {\r\n            richTextBox1.Paste();\r\n        }\r\n\r\n        private void удалитьToolStripMenuItem_Click(object sender, EventArgs e)\r\n        {\r\n            if (richTextBox1.SelectionLength > 0)\r\n            {\r\n                richTextBox1.SelectedText = string.Empty;\r\n            }\r\n        }\r\n\r\n        private void выделитьВсёToolStripMenuItem_Click(object sender, EventArgs e)\r\n        {\r\n            richTextBox1.SelectAll();\r\n        }\r\n\r\n        /*ТЕКСТ*/\r\n\r\n        private void постановкаЗадачиToolStripMenuItem_Click(object sender, EventArgs e)\r\n        {\r\n            MessageBox.Show(\r\n                    \"В результате выполнения курсовой работы был разработан синтаксический анализатор (парсер) для объявления списка с инициализацией на языке Python. Целью работы является создание программы, способной правильно анализировать и интерпретировать синтаксис списков с инициализацией в Python, используя грамматику и алгоритм для синтаксического анализа.\\n\\n\" +\r\n                    \"Задача парсера – корректно обработать конструкции, такие как:\\n\" +\r\n                    \"- объявление списка с числами: [1, 2, 3];\\n\" +\r\n                    \"- строковые списки: [\\\"a\\\", \\\"b\\\", \\\"c\\\"];\\n\" +\r\n                    \"- смешанные типы данных: [1, \\\"apple\\\", 3.14, True].\\n\\n\" +\r\n                    \"В рамках работы также был реализован механизм диагностики синтаксических ошибок и их нейтрализации.\",\r\n                    \"Постановка задачи\",\r\n                    MessageBoxButtons.OK,\r\n                    MessageBoxIcon.Information);\r\n        }\r\n\r\n        private void грамматикаToolStripMenuItem_Click(object sender, EventArgs e)\r\n        {\r\n            MessageBox.Show(\"1.\\t‹List› → ‹Letter›‹I›\\r\\n2.\\t‹I› → ‹Letter›‹I›\\r\\n3.\\t‹I› → ‹=›‹O›\\r\\n4.\\t‹O› → ‹[›‹P›\\r\\n5.\\t‹P› → ‹+|–›‹T›\\r\\n6.\\t‹P› → ‹Digit›‹TR›\\r\\n7.\\t‹P› → ‹”›‹S›\\r\\n8.\\t‹P› → ‹]›‹E›\\r\\n9.\\t‹T› → ‹Digit›‹TR›\\r\\n10.\\t‹TR› → ‹Digit›‹TR›\\r\\n11.\\t‹TR› → ‹,›‹P›\\r\\n12.\\t‹TR› → ‹.›‹F›\\r\\n13.\\t‹TR› → ‹]›‹E›\\r\\n14.\\t‹F› → ‹Digit›‹FR›\\r\\n15.\\t‹FR› → ‹Digit›‹FR›\\r\\n16.\\t‹FR› → ‹,›‹P›\\r\\n17.\\t‹FR› → ‹]›‹E›\\r\\n18.\\t‹S› → ‹Letter | Digit›‹SR›\\r\\n19.\\t‹SR› → ‹Letter | Digit›‹SR›\\r\\n20.\\t‹SR› → ‹”›‹A›\\r\\n21.\\t‹A› → ‹,›‹P›\\r\\n22.\\t‹A› → ‹]›‹E›\\r\\n23.\\t‹E› → ‹;›\\r\\n•\\t‹Digit› → “0” | “1” | “2” | “3” | “4” | “5” | “6” | “7” | “8” | “9”\\r\\n•\\t‹Letter› → “a” | “b” | “c” | ... | “z” | “A” | “B” | “C” | ... | “Z”\\r\\n\", \r\n                \"Грамматика\", \r\n                MessageBoxButtons.OK, \r\n                MessageBoxIcon.Information);\r\n        }\r\n\r\n        private void классификацияГрамматикиToolStripMenuItem_Click(object sender, EventArgs e)\r\n        {\r\n            MessageBox.Show(\"Согласно классификации Хомского, грамматика G[‹List›] является автоматной.\\r\\nПраворекурсивные правила:\\r\\nПравила, где рекурсивный вызов нетерминала находится в крайней правой позиции, что соответствует форме A → aB.\\r\\nВ данной грамматике такими являются:\\r\\n(2) ‹I› → ‹Letter›‹I›\\r\\n(10) ‹TR› → ‹Digit›‹TR›\\r\\n(15) ‹FR› → ‹Digit›‹FR›\\r\\n(19) ‹SR› → ‹Letter | Digit›‹SR›\\r\\nОстальные правила не содержат рекурсии или завершают цепочку продукций терминальным символом (правило (23) ‹E› → ‹;›).\\r\\nПоскольку все правила продукции имеют форму либо A → aB, либо A → a, грамматика является праворекурсивной и, следовательно, соответствует автоматной грамматике (регулярной грамматике, тип-3 по классификации Хомского). Это удовлетворяет требованию о том, что все правила должны быть либо леворекурсивными, либо праворекурсивными – в нашем случае они однородно праворекурсивные.\\r\\n\", \r\n                \"Классификация грамматики\", \r\n                MessageBoxButtons.OK, \r\n                MessageBoxIcon.Information);\r\n        }\r\n\r\n        private void методАнализаToolStripMenuItem_Click(object sender, EventArgs e)\r\n        {\r\n            MessageBox.Show(\r\n                    \"Для синтаксического анализа использован метод, основанный на автоматной грамматике, что позволяет эффективно обрабатывать конструкции объявлений списков. Программа использует праворекурсивные правила грамматики, что делает её достаточно простой и быстрой в выполнении.\\n\\n\" +\r\n                    \"Синтаксический анализатор использует стек и работает по принципу последовательного чтения входной цепочки символов. Если на текущем шаге встречается ошибка, то применяется метод нейтрализации ошибок, при котором некорректный символ или конструкция удаляется из цепочки до тех пор, пока не будет найдено допустимое продолжение.\\n\\n\" +\r\n                    \"Также для повышения устойчивости к ошибкам в процессе разбора были реализованы механизмы для пропуска некорректных данных, что помогает избежать неожиданных сбоев.\",\r\n                    \"Метод анализа\",\r\n                    MessageBoxButtons.OK,\r\n                    MessageBoxIcon.Information);\r\n        }\r\n\r\n        private void диагностикаИНейтрализацияОшибокToolStripMenuItem_Click(object sender, EventArgs e)\r\n        {\r\n            MessageBox.Show(\r\n                    \"Для диагностики синтаксических ошибок используется алгоритм, который анализирует входную строку и ищет места, где структура данных не соответствует ожидаемой грамматике. В случае нахождения ошибки, программа автоматически применяет метод нейтрализации ошибок.\\n\\n\" +\r\n                    \"Метод нейтрализации заключается в удалении символа из текущей цепочки и попытке продолжить анализ с этого момента. Это позволяет корректно обработать ошибочные данные и продолжить выполнение программы. Такой подход позволяет избежать остановки выполнения программы при возникновении ошибок, а также помогает обработать некорректные, но исправляемые данные.\",\r\n                    \"Диагностика и нейтрализация ошибок\",\r\n                    MessageBoxButtons.OK,\r\n                    MessageBoxIcon.Information);\r\n        }\r\n\r\n        private void текстовыйПримерToolStripMenuItem_Click(object sender, EventArgs e)\r\n        {\r\n            MessageBox.Show(\r\n                    \"Пример 1:\\nСписок с числами:\\n\\nlist_example = [1, 2, 3]\\n\\nРезультат: Синтаксический анализ успешен, программа интерпретирует список как коллекцию целых чисел.\\n\\n\" +\r\n                    \"Пример 2:\\nСписок с разными типами данных:\\n\\nlist_example = [1, \\\"apple\\\", 3.14, True]\\n\\n\",\r\n                    \"Тестовый пример\",\r\n                    MessageBoxButtons.OK,\r\n                    MessageBoxIcon.Information);\r\n        }\r\n\r\n        private void списокЛитературыToolStripMenuItem_Click(object sender, EventArgs e)\r\n        {\r\n            MessageBox.Show(\r\n                \"1. Шорников Ю.В. Теория и практика языковых процессоров : учеб. пособие / Ю.В. Шорников. – Новосибирск: Изд-во НГТУ, 2022.\\n\\n\" +\r\n                \"2. Gries D. Designing Compilers for Digital Computers. New York, Jhon Wiley, 1971. 493 p.\\n\\n\" +\r\n                \"3. Теория формальных языков и компиляторов [Электронный ресурс] / Электрон. дан. URL: https://dispace.edu.nstu.ru/didesk/course/show/8594, свободный. Яз.рус. (дата обращения 25.03.2025).\\n\\n\",\r\n                \"Список литературы\",\r\n                MessageBoxButtons.OK,\r\n                MessageBoxIcon.Information);\r\n        }\r\n\r\n        private void исходныйКодПрограммыToolStripMenuItem_Click(object sender, EventArgs e)\r\n        {\r\n            SourceCodeForm sourceCodeForm = new SourceCodeForm();\r\n            sourceCodeForm.ShowDialog();\r\n        }\r\n\r\n\r\n        /*СПРАВКА*/\r\n\r\n\r\n        private void вызовСправкиToolStripMenuItem_Click(object sender, EventArgs e)\r\n        {\r\n            try\r\n            {\r\n                string helpFilePath = Path.Combine(Application.StartupPath, \"help.html\");\r\n\r\n                // Запускаем браузер по умолчанию с этим файлом\r\n                Process.Start(helpFilePath);\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                MessageBox.Show(\"Не удалось открыть файл справки: \" + ex.Message);\r\n            }\r\n        }\r\n\r\n        private void оПрограммеToolStripMenuItem_Click(object sender, EventArgs e)\r\n        {\r\n            MessageBox.Show(\r\n                \"Данная программа представляет собой компилятор, в частности лексер, который сканирует строку и разбивает её на лексемы и в случае нахождения ошибки заканчивает сканирование\",\r\n                \"О программе\",\r\n                MessageBoxButtons.OK,\r\n                MessageBoxIcon.Information\r\n            );\r\n        }\r\n\r\n\r\n        /*ПУСК*/\r\n\r\n\r\n        private void toolStripDropDownButton4_Click(object sender, EventArgs e)\r\n        {\r\n            toolStripButtonRun_Click(sender, e);\r\n        }\r\n\r\n        /*ПАНЕЛЬ ИНСТРУМЕНТОВ*/\r\n\r\n\r\n        private void toolStripButtonNew_Click(object sender, EventArgs e)\r\n        {\r\n            создатьToolStripMenuItem_Click(sender, e);\r\n        }\r\n\r\n        private void toolStripButtonOpen_Click(object sender, EventArgs e)\r\n        {\r\n            открытьToolStripMenuItem_Click(sender, e);\r\n        }\r\n\r\n        private void toolStripButtonSave_Click(object sender, EventArgs e)\r\n        {\r\n            сохранитьToolStripMenuItem_Click(sender, e);\r\n        }\r\n\r\n        private void toolStripButtonUndo_Click(object sender, EventArgs e)\r\n        {\r\n            отменитьToolStripMenuItem_Click(sender, e);\r\n        }\r\n\r\n        private void toolStripButtonRedo_Click(object sender, EventArgs e)\r\n        {\r\n            повторитьToolStripMenuItem_Click(sender, e);\r\n        }\r\n\r\n        private void toolStripButtonCopy_Click(object sender, EventArgs e)\r\n        {\r\n            копироватьToolStripMenuItem_Click(sender, e);\r\n        }\r\n\r\n        private void toolStripButtonCut_Click(object sender, EventArgs e)\r\n        {\r\n            вырезатьToolStripMenuItem_Click(sender, e);\r\n        }\r\n\r\n        private void toolStripButtonPaste_Click(object sender, EventArgs e)\r\n        {\r\n            вставитьToolStripMenuItem_Click(sender, e);\r\n        }\r\n\r\n        private void toolStripButtonRun_Click(object sender, EventArgs e)\r\n        {\r\n            // Получаем исходный код из текстового поля\r\n            string sourceCode = richTextBox1.Text;\r\n\r\n            // Создаем объект сканера и выполняем анализ\r\n            Scanner scanner = new Scanner();\r\n            var tokens = scanner.Scan(sourceCode);\r\n\r\n            // Очищаем DataGridView\r\n            textBoxErrors.Visible = false;\r\n            dataGridViewoutput.Visible = true;\r\n            dataGridViewoutput.Rows.Clear();\r\n            dataGridViewoutput.Columns.Clear();\r\n\r\n            // Добавляем столбцы\r\n            dataGridViewoutput.Columns.Add(\"colCode\", \"Код\");\r\n            dataGridViewoutput.Columns.Add(\"colType\", \"Тип лексемы\");\r\n            dataGridViewoutput.Columns.Add(\"colLexeme\", \"Лексема\");\r\n            dataGridViewoutput  .Columns.Add(\"colLine\", \"Строка\");\r\n            dataGridViewoutput.Columns.Add(\"colStart\", \"Начальная позиция\");\r\n            dataGridViewoutput.Columns.Add(\"colEnd\", \"Конечная позиция\");\r\n\r\n            // Заполняем DataGridView данными токенов\r\n            foreach (var token in tokens)\r\n            {\r\n                dataGridViewoutput.Rows.Add(\r\n                    (int)token.Code,\r\n                    token.Type,\r\n                    token.Lexeme,\r\n                    token.Line,\r\n                    token.StartPos,\r\n                    token.EndPos\r\n                );\r\n            }\r\n\r\n            /*ListParser parser = new ListParser();\r\n            parser.Parse(sourceCode);\r\n            textBoxErrors.Visible = true;\r\n            // Вывод ошибок, обнаруженных парсером, в текстовое поле\r\n            if (parser.Errors.Any())\r\n            {\r\n                textBoxErrors.Text = string.Join(Environment.NewLine, parser.Errors.Select(err => err.ToString()));\r\n            }\r\n            else\r\n            {\r\n                textBoxErrors.Text = \"Ошибок не обнаружено\";\r\n            }*/\r\n        }\r\n\r\n        private void toolStripButtonHelp_Click(object sender, EventArgs e)\r\n        {\r\n            вызовСправкиToolStripMenuItem_Click(sender, e);\r\n        }\r\n\r\n        private void toolStripButtonAbout_Click(object sender, EventArgs e)\r\n        {\r\n            оПрограммеToolStripMenuItem_Click(sender, e);\r\n        }\r\n\r\n        private void Form1_FormClosing(object sender, FormClosingEventArgs e)\r\n        {\r\n            // Если в редакторе есть текст (возможно, изменения)\r\n            if (!string.IsNullOrWhiteSpace(richTextBox1.Text))\r\n            {\r\n                DialogResult result = MessageBox.Show(\r\n                    \"Сохранить изменения в текущем документе?\",\r\n                    \"Сохранение изменений\",\r\n                    MessageBoxButtons.YesNo,\r\n                    MessageBoxIcon.Question);\r\n\r\n                if (result == DialogResult.Yes)\r\n                {\r\n                    // Вызываем функцию \"Сохранить как\" для сохранения изменений\r\n                    сохранитьКакToolStripMenuItem_Click(sender, e);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n";
        }

        private void ScannerButton_Click(object sender, EventArgs e)
        {
            richTextBox.Clear();
            richTextBox.Text = "using System.Collections.Generic;\r\nusing System.Text;\r\n\r\nnamespace Laba1\r\n{\r\n    \r\n    public enum TokenCode\r\n    {\r\n        Integer = 1,        // целое\r\n        Float = 2,          // вещественное\r\n        Identifier = 3,     // идентификатор\r\n        AssignOp = 4,       // \"=\"\r\n        Minus = 5,          // (если бы мы хотели отдельный токен)\r\n        Comma = 6,          // \",\"\r\n        LBracket = 7,       // \"[\"\r\n        RBracket = 8,       // \"]\"\r\n        Semicolon = 9,      // \";\"\r\n        StringLiteral = 10, // \"...\" строка\r\n        Plus = 11,\r\n        String = 12,\r\n        Error = 99\r\n    }\r\n\r\n    public class Token\r\n    {\r\n        public TokenCode Code { get; set; }\r\n        public string Type { get; set; }\r\n        public string Lexeme { get; set; }\r\n        public int StartPos { get; set; }\r\n        public int EndPos { get; set; }\r\n        public int Line { get; set; }\r\n\r\n        public override string ToString()\r\n        {\r\n            return $\"[{Line}:{StartPos}-{EndPos}] ({Code}) {Type} : '{Lexeme}'\";\r\n        }\r\n    }\r\n\r\n    public class Scanner\r\n    {\r\n        private string _text;\r\n        private int _pos;       // текущая позиция (сквозная по всему тексту)\r\n        private int _line;      // текущая строка\r\n        private int _linePos;   // позиция в текущей строке\r\n        private List<Token> _tokens;\r\n\r\n        // Пример набора ключевых слов\r\n        private HashSet<string> _keywords = new HashSet<string> { \"List\" };\r\n\r\n        public Scanner()\r\n        {\r\n            _tokens = new List<Token>();\r\n        }\r\n\r\n        public List<Token> Scan(string text)\r\n        {\r\n            _text = text;\r\n            _pos = 0;\r\n            _line = 1;\r\n            _linePos = 1;\r\n            _tokens.Clear();\r\n\r\n            while (!IsEnd())\r\n            {\r\n                char ch = CurrentChar();\r\n\r\n                switch (ch)\r\n                {\r\n                    // Пропускаем незначащие пробелы, табуляцию и переводы строк\r\n                    case var c when char.IsWhiteSpace(c):\r\n                        Advance();\r\n                        break;\r\n\r\n                    // Буква - значит начинаем считывать идентификатор\r\n                    case var c when char.IsLetter(c) &&  c >= 65 && c <= 122:\r\n                        ReadIdentifierOrKeyword();\r\n                        break;\r\n\r\n                    // Минус: может быть частью числа (например, -5 или -2.3)\r\n                    case '-':\r\n                        AddToken(TokenCode.Minus, \" знак минус \", \"-\");\r\n                        Advance();\r\n                        break;\r\n\r\n                    case '+':\r\n                        AddToken(TokenCode.Plus, \" знак плюс \", \"+\");\r\n                        Advance();\r\n                        break;\r\n\r\n                    // Цифра - читаем число (целое или вещественное)\r\n                    case var c when char.IsDigit(c):\r\n                        ReadNumber();\r\n                        break;\r\n\r\n                    // Оператор присваивания\r\n                    case '=':\r\n                        AddToken(TokenCode.AssignOp, \" оператор присваивания \", \"=\");\r\n                        Advance();\r\n                        break;\r\n\r\n                    // Открывающая скобка\r\n                    case '[':\r\n                        AddToken(TokenCode.LBracket, \" открывающая скобка \", \"[\");\r\n                        Advance();\r\n                        break;\r\n\r\n                    // Закрывающая скобка\r\n                    case ']':\r\n                        AddToken(TokenCode.RBracket, \" закрывающая скобка \", \"]\");\r\n                        Advance();\r\n                        break;\r\n\r\n                    // Запятая\r\n                    case ',':\r\n                        AddToken(TokenCode.Comma, \" запятая \", \",\");\r\n                        Advance();\r\n                        break;\r\n\r\n                    // Точка с запятой\r\n                    case ';':\r\n                        AddToken(TokenCode.Semicolon, \"конец оператора\", \";\");\r\n                        Advance();\r\n                        break;\r\n\r\n                    // Строка (начинается на \")\r\n                    case '\"':\r\n                        AddToken(TokenCode.String, \" кавычка \", \" '' \");\r\n                        ReadStringLiteral();\r\n                        Advance();\r\n                        break;\r\n\r\n                    // По умолчанию - недопустимый символ\r\n                    default:\r\n                        AddToken(TokenCode.Error, \" недопустимый символ \", ch.ToString());\r\n                        Advance();\r\n                        return _tokens;\r\n                }\r\n            }\r\n\r\n            return _tokens;\r\n        }\r\n\r\n\r\n        /// <summary>\r\n        /// Считывание идентификатора\r\n        /// </summary>\r\n        private void ReadIdentifierOrKeyword()\r\n        {\r\n            int startPos = _linePos;\r\n            var sb = new StringBuilder();\r\n\r\n            // Разрешаем только латинские буквы\r\n            while (!IsEnd() && IsLatinLetter(CurrentChar()))\r\n            {\r\n                sb.Append(CurrentChar());\r\n                Advance();\r\n            }\r\n\r\n            string lexeme = sb.ToString();\r\n            if (_keywords.Contains(lexeme))\r\n                AddToken(TokenCode.Identifier, \" идентификатор \", lexeme, startPos, _linePos - 1, _line);\r\n        }\r\n\r\n        // Метод для проверки, является ли символ латинской буквой\r\n        private bool IsLatinLetter(char ch)\r\n        {\r\n            return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z');\r\n        }\r\n\r\n\r\n        /// <summary>\r\n        /// Считывание числа (целое или вещественное, может быть с минусом)\r\n        /// </summary>\r\n        private void ReadNumber()\r\n        {\r\n            int startPos = _linePos;\r\n            bool hasDot = false;\r\n\r\n            StringBuilder sb = new StringBuilder();\r\n\r\n            // Может начинаться с минуса\r\n            if (CurrentChar() == '-')\r\n            {\r\n                sb.Append(CurrentChar());\r\n                Advance();\r\n            }\r\n\r\n            // Основной цикл\r\n            while (!IsEnd())\r\n            {\r\n                char ch = CurrentChar();\r\n                if (char.IsDigit(ch))\r\n                {\r\n                    sb.Append(ch);\r\n                    Advance();\r\n                }\r\n                else if (ch == '.')\r\n                {\r\n                    if (hasDot)\r\n                    {\r\n                        // Повторная точка - прерываем, либо помечаем ошибку\r\n                        break;\r\n                    }\r\n                    else\r\n                    {\r\n                        hasDot = true;\r\n                        sb.Append(ch);\r\n                        Advance();\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    // Не цифра и не точка - конец числа\r\n                    break;\r\n                }\r\n            }\r\n\r\n            string numberLexeme = sb.ToString();\r\n\r\n            if (hasDot)\r\n            {\r\n                AddToken(TokenCode.Float, \" вещественное число \", numberLexeme, startPos, _linePos - 1, _line);\r\n            }\r\n            else\r\n            {\r\n                AddToken(TokenCode.Integer, \" целое число \", numberLexeme, startPos, _linePos - 1, _line);\r\n            }\r\n        }\r\n\r\n        /// <summary>\r\n        /// Считывание строкового литерала (открывающая кавычка уже считана)\r\n        /// </summary>\r\n        private void ReadStringLiteral()\r\n        {\r\n            int startPos = _linePos;  // позиция открывающей кавычки\r\n            StringBuilder sb = new StringBuilder();\r\n\r\n            // Пропускаем открывающую кавычку\r\n            Advance(); // уходим за '\"'\r\n            bool closed = false;\r\n\r\n            while (!IsEnd())\r\n            {\r\n                char ch = CurrentChar();\r\n                if (ch == '\"')\r\n                {\r\n                    // нашли закрывающую кавычку\r\n                    closed = true;\r\n                    AddToken(TokenCode.String, \" закрывающая кавычка \", \" '' \");\r\n                    Advance(); // пропускаем закрывающую кавычку\r\n                    break;\r\n                }\r\n                else\r\n                {\r\n                    // добавляем символ в строку (включая пробелы)\r\n                    sb.Append(ch);\r\n                    Advance();\r\n                }\r\n            }\r\n\r\n            string strValue = sb.ToString();\r\n            if (!closed)\r\n            {\r\n                // Строка не закрылась\r\n                AddToken(TokenCode.Error, \" незакрытая строка \", strValue, startPos, _linePos - 1, _line);\r\n            }\r\n            else\r\n            {\r\n                // Закрытая строка\r\n                AddToken(TokenCode.StringLiteral, \" строка \", strValue, startPos, _linePos - 1, _line);\r\n            }\r\n        }\r\n\r\n        #region Вспомогательные методы\r\n\r\n        private bool IsEnd()\r\n        {\r\n            return _pos >= _text.Length;\r\n        }\r\n\r\n        private char CurrentChar()\r\n        {\r\n            if (IsEnd()) return '\\0';\r\n            return _text[_pos];\r\n        }\r\n\r\n        private void Advance()\r\n        {\r\n            // Если встретили перевод строки, переходим на следующую строку\r\n            if (CurrentChar() == '\\n')\r\n            {\r\n                _line++;\r\n                _linePos = 0;\r\n            }\r\n            _pos++;\r\n            _linePos++;\r\n        }\r\n\r\n        private void AddToken(TokenCode code, string type, string lexeme)\r\n        {\r\n            AddToken(code, type, lexeme, _linePos, _linePos, _line);\r\n        }\r\n\r\n        private void AddToken(TokenCode code, string type, string lexeme, int startPos, int endPos, int line)\r\n        {\r\n            var token = new Token\r\n            {\r\n                Code = code,\r\n                Type = type,\r\n                Lexeme = lexeme,\r\n                StartPos = startPos,\r\n                EndPos = endPos,\r\n                Line = line\r\n            };\r\n            _tokens.Add(token);\r\n        }\r\n\r\n        #endregion\r\n    }\r\n}\r\n";
        }

        private void ParserButton_Click(object sender, EventArgs e)
        {
            richTextBox.Clear();
            richTextBox.Text = "using System.Collections.Generic;\r\n\r\nnamespace Laba1\r\n{\r\n    public class ParseError\r\n    {\r\n        public string Message { get; set; }  // Текст ошибки\r\n        public char Symbol { get; set; }  // Какой символ вызвал ошибку (или '\\0', если конец строки)\r\n        public int Position { get; set; } // Позиция в строке (0-based или 1-based — на ваш выбор)\r\n\r\n        public ParseError(string message, char symbol, int position)\r\n        {\r\n            Message = message;\r\n            Symbol = symbol;\r\n            Position = position;\r\n        }\r\n\r\n        public override string ToString()\r\n        {\r\n            return $\" [Позиция {Position}] ' {Message} ' \";\r\n        }\r\n    }\r\n\r\n    public class ListParser\r\n    {\r\n        private string _input;\r\n        private int _pos; // Текущая позиция в строке\r\n        public List<ParseError> Errors { get; private set; }\r\n        private const char EOF = '\\0'; // Для удобства это конец строки\r\n\r\n        public ListParser()\r\n        {\r\n            Errors = new List<ParseError>();\r\n        }\r\n\r\n        public void Parse(string input)\r\n        {\r\n            _input = input ?? \"\";\r\n            _pos = 0;\r\n            Errors.Clear();\r\n\r\n            // Шаг 1. <START> = <ID> '=' '[' <ELEMS> ']' ';'\r\n            SkipSpaces();\r\n            ParseIdentifier();      // <ID>\r\n            SkipSpaces();\r\n\r\n            if (!TryReadChar('='))\r\n            {\r\n                AddError(\"Ожидался символ '='\", CurrentChar());\r\n                AdvancePos();\r\n            }\r\n            SkipSpaces();\r\n\r\n            if (!TryReadChar('['))\r\n            {\r\n                AddError(\"Ожидался символ '['\", CurrentChar());\r\n                AdvancePos();\r\n            }\r\n            SkipSpaces();\r\n\r\n            ParseElements();        // <ELEMS>\r\n            SkipSpaces();\r\n\r\n            if (!TryReadChar(']'))\r\n            {\r\n                AddError(\"Ожидался символ ']'\", CurrentChar());\r\n                AdvancePos();\r\n            }\r\n            SkipSpaces();\r\n\r\n            if (!TryReadChar(';'))\r\n            {\r\n                AddError(\"Ожидался символ ';' в конце\", CurrentChar());\r\n                AdvancePos();\r\n            }\r\n            SkipSpaces();\r\n\r\n            // Проверка на лишние символы после конца списка\r\n            if (!IsEOF())\r\n            {\r\n                AddError(\"Лишние символы после конца списка\", CurrentChar());\r\n                while (!IsEOF())\r\n                {\r\n                    AdvancePos();\r\n                }\r\n            }\r\n        }\r\n\r\n        private void ParseIdentifier()\r\n        {\r\n            if (!IsLetter(CurrentChar()))\r\n            {\r\n                AddError(\"Идентификатор должен начинаться с английской буквы\", CurrentChar());\r\n                AdvancePos();\r\n                return;\r\n            }\r\n            AdvancePos();\r\n            while (IsLetter(CurrentChar()))\r\n            {\r\n                AdvancePos();\r\n            }\r\n\r\n            // После идентификатора может быть недопустимый символ\r\n            if (IsInvalidCharacter(CurrentChar()))\r\n            {\r\n                AddError(\"Недопустимый символ в идентификаторе\", CurrentChar());\r\n                AdvancePos();\r\n            }\r\n        }\r\n\r\n        private void ParseElements()\r\n        {\r\n            SkipSpaces();\r\n\r\n            if (CurrentChar() == ']')\r\n            {\r\n                return;\r\n            }\r\n\r\n            ParseElement();\r\n\r\n            while (true)\r\n            {\r\n                SkipSpaces();\r\n                if (CurrentChar() == ',')\r\n                {\r\n                    AdvancePos();\r\n                    SkipSpaces();\r\n\r\n                    if (CurrentChar() == ']')\r\n                    {\r\n                        break;\r\n                    }\r\n                    ParseElement();\r\n                }\r\n                else\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        private void ParseElement()\r\n        {\r\n            SkipSpaces();\r\n\r\n            char c = CurrentChar();\r\n            if (c == '\"')\r\n            {\r\n                ParseString();\r\n            }\r\n            else if (c == '+' || c == '-' || char.IsDigit(c))\r\n            {\r\n                ParseNumber();\r\n            }\r\n            else if (IsInvalidCharacter(c))\r\n            {\r\n                AddError(\"Недопустимый символ в элементе\", c);\r\n                AdvancePos();\r\n            }\r\n            else\r\n            {\r\n                AddError(\"Ожидался элемент (число или строка)\", c);\r\n                AdvancePos();\r\n                SkipUntilDelimiter();\r\n            }\r\n        }\r\n\r\n        private void ParseString()\r\n        {\r\n            if (!TryReadChar('\"'))\r\n            {\r\n                AddError(\"Ожидался символ '\\\"' при начале строки\", CurrentChar());\r\n                AdvancePos();\r\n                return;\r\n            }\r\n            while (!IsEOF() && CurrentChar() != '\"')\r\n            {\r\n                AdvancePos();\r\n            }\r\n            if (CurrentChar() == '\"')\r\n            {\r\n                AdvancePos();\r\n            }\r\n            else\r\n            {\r\n                AddError(\"Строка не закрыта кавычкой\", CurrentChar());\r\n            }\r\n        }\r\n\r\n        private void ParseNumber()\r\n        {\r\n            if (CurrentChar() == '+' || CurrentChar() == '-')\r\n            {\r\n                AdvancePos();\r\n            }\r\n\r\n            if (!IsDigit(CurrentChar()))\r\n            {\r\n                AddError(\"После знака числа ожидается цифра\", CurrentChar());\r\n                AdvancePos();\r\n                SkipUntilDelimiter();\r\n                return;\r\n            }\r\n\r\n            while (IsDigit(CurrentChar()))\r\n            {\r\n                AdvancePos();\r\n            }\r\n\r\n            if (CurrentChar() == '.')\r\n            {\r\n                AdvancePos();\r\n                if (!IsDigit(CurrentChar()))\r\n                {\r\n                    AddError(\"После точки ожидается хотя бы одна цифра\", CurrentChar());\r\n                    AdvancePos();\r\n                    SkipUntilDelimiter();\r\n                    return;\r\n                }\r\n                while (IsDigit(CurrentChar()))\r\n                {\r\n                    AdvancePos();\r\n                }\r\n            }\r\n        }\r\n\r\n        private bool IsLetter(char c)\r\n        {\r\n            return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');\r\n        }\r\n\r\n        private bool IsDigit(char c)\r\n        {\r\n            return (c >= '0' && c <= '9');\r\n        }\r\n\r\n        private bool IsInvalidCharacter(char c)\r\n        {\r\n            // Проверка на недопустимые символы (например, специальные символы)\r\n            return !IsLetter(c) && !IsDigit(c) && c != '+' && c != '-' && c != '.' && c != ',' && c != '\"' && c != '[' && c != ']' && c != '=' && c != ';' && !char.IsWhiteSpace(c);\r\n        }\r\n\r\n        private void SkipSpaces()\r\n        {\r\n            while (!IsEOF() && char.IsWhiteSpace(CurrentChar()))\r\n            {\r\n                AdvancePos();\r\n            }\r\n        }\r\n\r\n        private char CurrentChar()\r\n        {\r\n            if (_pos >= _input.Length)\r\n                return EOF;\r\n            return _input[_pos];\r\n        }\r\n\r\n        private bool IsEOF()\r\n        {\r\n            return _pos >= _input.Length;\r\n        }\r\n\r\n        private void AdvancePos()\r\n        {\r\n            if (_pos < _input.Length) _pos++;\r\n        }\r\n\r\n        private bool TryReadChar(char expected)\r\n        {\r\n            if (CurrentChar() == expected)\r\n            {\r\n                AdvancePos();\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        private void AddError(string message, char symbol)\r\n        {\r\n            Errors.Add(new ParseError(message, symbol, _pos));\r\n        }\r\n\r\n        private void SkipUntilDelimiter()\r\n        {\r\n            while (!IsEOF())\r\n            {\r\n                char c = CurrentChar();\r\n                if (c == ',' || c == ']' || c == ';')\r\n                {\r\n                    break;\r\n                }\r\n                AdvancePos();\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n}\r\n";
        }

        private void ExButton_Click(object sender, EventArgs e)
        {
            Close();
        }
    }
}
